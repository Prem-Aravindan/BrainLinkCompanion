import { EEG_CONFIG } from '../constants';
import { createEEGProcessor } from './eegProcessing';

// Create advanced EEG processor instance
const advancedProcessor = createEEGProcessor(EEG_CONFIG.SAMPLING_RATE);

class EEGProcessor {
  /**
   * Process raw EEG data from BrainLink device using advanced pipeline
   */
  static processRawData(rawData) {
    try {
      console.log(`üìä Processing EEG data: ${typeof rawData === 'number' ? rawData.toFixed(2) : rawData}`);
      
      // Handle different data formats
      let values = [];
      
      if (typeof rawData === 'number') {
        // Single numeric value (most common for BrainLink)
        values = [rawData];
      } else if (typeof rawData === 'string') {
        // Try to parse as number first
        const numValue = parseFloat(rawData.trim());
        if (!isNaN(numValue)) {
          values = [numValue];
        } else {
          // BrainLink typically sends comma-separated values or single values
          if (rawData.includes(',')) {
            values = rawData.split(',').map(val => parseFloat(val.trim()));
          } else {
            console.warn('‚ö†Ô∏è Cannot parse string data as EEG value:', rawData);
            return [];
          }
        }
      } else if (Array.isArray(rawData)) {
        values = rawData.map(val => parseFloat(val));
      } else {
        console.warn('‚ö†Ô∏è Unsupported data type:', typeof rawData);
        return [];
      }
      
      // Filter out invalid values
      const validValues = values.filter(val => !isNaN(val) && isFinite(val));
      
      if (validValues.length === 0) {
        console.warn('‚ö†Ô∏è No valid EEG values found in data:', rawData);
        return [];
      }

      console.log(`‚úÖ Processed ${validValues.length} EEG values:`, validValues.map(v => v.toFixed(2)));
      
      // Return raw values in microvolts for proper signal processing
      return validValues;
    } catch (error) {
      console.error('‚ùå Error processing raw EEG data:', error);
      return [];
    }
  }

  /**
   * Normalize EEG value to reasonable range for visualization
   */
  static normalizeValue(value) {
    // BrainLink values are typically in microvolts (-4096 to +4096 ¬µV)
    // Normalize to a range suitable for visualization (-1 to 1)
    const minVal = -4096;
    const maxVal = 4096;
    
    // Clamp and normalize
    const clampedValue = Math.max(minVal, Math.min(maxVal, value));
    return (clampedValue - minVal) / (maxVal - minVal) * 2 - 1;
  }

  /**
   * Apply Butterworth bandpass filter (equivalent to Python scipy.signal.butter + filtfilt)
   */
  static bandpassFilter(data, lowcut, highcut, fs = EEG_CONFIG.SAMPLING_RATE, order = 2) {
    if (data.length < order * 3) return data;

    const nyquist = fs / 2;
    const low = lowcut / nyquist;
    const high = highcut / nyquist;
    
    // Simple IIR filter approximation
    // This is a simplified implementation - for production, use a proper DSP library
    const filtered = [...data];
    
    // Apply multiple passes for better filtering
    for (let pass = 0; pass < order; pass++) {
      // Forward pass
      for (let i = 1; i < filtered.length; i++) {
        const weight = Math.exp(-2 * Math.PI * low);
        filtered[i] = weight * filtered[i-1] + (1 - weight) * filtered[i];
      }
      
      // Backward pass for zero-phase filtering (like filtfilt)
      for (let i = filtered.length - 2; i >= 0; i--) {
        const weight = Math.exp(-2 * Math.PI * high);
        filtered[i] = weight * filtered[i+1] + (1 - weight) * filtered[i];
      }
    }
    
    return filtered;
  }

  /**
   * Apply notch filter to remove power line interference (50Hz/60Hz)
   */
  static notchFilter(data, fs = EEG_CONFIG.SAMPLING_RATE, notchFreq = 50, qualityFactor = 30) {
    if (data.length < 5) return data;

    // Calculate filter coefficients for notch filter
    const omega = 2 * Math.PI * notchFreq / fs;
    const alpha = Math.sin(omega) / (2 * qualityFactor);
    
    const b0 = 1;
    const b1 = -2 * Math.cos(omega);
    const b2 = 1;
    const a0 = 1 + alpha;
    const a1 = -2 * Math.cos(omega);
    const a2 = 1 - alpha;
    
    // Apply IIR filter
    const filtered = new Array(data.length);
    filtered[0] = data[0];
    filtered[1] = data[1];
    
    for (let i = 2; i < data.length; i++) {
      filtered[i] = (
        b0 * data[i] + 
        b1 * data[i-1] + 
        b2 * data[i-2] - 
        a1 * filtered[i-1] - 
        a2 * filtered[i-2]
      ) / a0;
    }
    
    return filtered;
  }

  /**
   * Calculate Power Spectral Density using Welch's method (equivalent to scipy.signal.welch)
   */
  static calculatePSD(data, fs = EEG_CONFIG.SAMPLING_RATE, nperseg = EEG_CONFIG.WINDOW_SIZE, noverlap = EEG_CONFIG.OVERLAP_SIZE) {
    const N = data.length;
    if (N < nperseg) {
      // If data is shorter than window size, use the entire data
      nperseg = N;
      noverlap = 0;
    }
    
    const hop = nperseg - noverlap;
    const numSegments = Math.floor((N - noverlap) / hop);
    
    if (numSegments === 0) {
      return { frequencies: [], powers: [] };
    }
    
    // Initialize PSD accumulator
    const freqBins = Math.floor(nperseg / 2) + 1;
    const psdSum = new Array(freqBins).fill(0);
    
    // Process each segment
    for (let segIdx = 0; segIdx < numSegments; segIdx++) {
      const start = segIdx * hop;
      const segment = data.slice(start, start + nperseg);
      
      // Apply Hamming window
      const windowed = this.applyHammingWindow(segment);
      
      // Calculate FFT and PSD for this segment
      const fft = this.calculateFFT(windowed);
      
      for (let k = 0; k < freqBins; k++) {
        const real = fft.real[k] || 0;
        const imag = fft.imag[k] || 0;
        psdSum[k] += (real * real + imag * imag) / (fs * nperseg);
      }
    }
    
    // Average across segments
    const powers = psdSum.map(sum => sum / numSegments);
    const frequencies = Array.from({ length: freqBins }, (_, k) => k * fs / nperseg);
    
    return { frequencies, powers };
  }

  /**
   * Apply Hamming window to data
   */
  static applyHammingWindow(data) {
    const N = data.length;
    const windowed = new Array(N);
    
    for (let n = 0; n < N; n++) {
      const window = 0.54 - 0.46 * Math.cos(2 * Math.PI * n / (N - 1));
      windowed[n] = data[n] * window;
    }
    
    return windowed;
  }

  /**
   * Calculate FFT (simplified DFT implementation)
   */
  static calculateFFT(data) {
    const N = data.length;
    const real = new Array(N);
    const imag = new Array(N);
    
    for (let k = 0; k < N; k++) {
      real[k] = 0;
      imag[k] = 0;
      
      for (let n = 0; n < N; n++) {
        const angle = -2 * Math.PI * k * n / N;
        real[k] += data[n] * Math.cos(angle);
        imag[k] += data[n] * Math.sin(angle);
      }
    }
    
    return { real, imag };
  }

  /**
   * Calculate band powers using advanced processing pipeline (matches Python implementation)
   */
  static calculateBandPowers(data, fs = EEG_CONFIG.SAMPLING_RATE) {
    if (data.length < EEG_CONFIG.WINDOW_SIZE) {
      return {
        delta: 0,
        theta: 0,
        alpha: 0,
        beta: 0,
        gamma: 0,
        totalPower: 0,
        thetaContribution: 0,
        thetaSNR: 0,
        thetaPeakSNR: 0,
      };
    }

    try {
      // Use advanced processing pipeline from eegProcessing.js
      const result = advancedProcessor.process(data);
      
      console.log(`üß† Advanced Processing Results:`);
      console.log(`   Delta: ${result.bandPowers.delta.toFixed(2)}, ` +
                  `Theta: ${result.bandPowers.theta.toFixed(2)}, ` +
                  `Alpha: ${result.bandPowers.alpha.toFixed(2)}, ` +
                  `Beta: ${result.bandPowers.beta.toFixed(2)}, ` +
                  `Gamma: ${result.bandPowers.gamma.toFixed(2)}`);
      console.log(`   Theta Contribution: ${result.thetaMetrics.thetaContribution.toFixed(1)}%`);
      console.log(`   Peak SNR: ${result.thetaMetrics.thetaSNRPeak.toFixed(2)}`);
      console.log(`   Smoothed Theta: ${result.thetaMetrics.smoothedTheta.toFixed(1)}%`);

      // Calculate relative powers
      const totalBandPower = result.bandPowers.delta + result.bandPowers.theta + 
                           result.bandPowers.alpha + result.bandPowers.beta + 
                           result.bandPowers.gamma + 0.001;

      return {
        // Absolute powers
        delta: result.bandPowers.delta,
        theta: result.bandPowers.theta,
        alpha: result.bandPowers.alpha,
        beta: result.bandPowers.beta,
        gamma: result.bandPowers.gamma,
        totalPower: result.thetaMetrics.totalPower,
        
        // Relative powers (normalized to sum to 1)
        relativeDelta: result.bandPowers.delta / totalBandPower,
        relativeTheta: result.bandPowers.theta / totalBandPower,
        relativeAlpha: result.bandPowers.alpha / totalBandPower,
        relativeBeta: result.bandPowers.beta / totalBandPower,
        relativeGamma: result.bandPowers.gamma / totalBandPower,
        
        // Advanced metrics (matches Python)
        thetaContribution: result.thetaMetrics.thetaContribution,
        thetaSNR: result.thetaMetrics.thetaSNRBroad,
        thetaPeakSNR: result.thetaMetrics.thetaSNRPeak,
        
        // Store the complete result for API payload
        advancedResult: result
      };
    } catch (error) {
      console.error('‚ùå Advanced EEG processing failed, falling back to basic processing:', error);
      return this.calculateBandPowersBasic(data, fs);
    }
  }

  /**
   * Apply simple low-pass filter to reduce noise
   */
  static lowPassFilter(data, cutoffFreq = 50) {
    if (data.length < 3) return data;

    const samplingRate = EEG_CONFIG.SAMPLING_RATE;
    const rc = 1.0 / (cutoffFreq * 2 * Math.PI);
    const dt = 1.0 / samplingRate;
    const alpha = dt / (rc + dt);

    const filtered = [data[0]];
    
    for (let i = 1; i < data.length; i++) {
      filtered[i] = filtered[i - 1] + alpha * (data[i] - filtered[i - 1]);
    }

    return filtered;
  }

  /**
   * Apply simple high-pass filter to remove DC offset
   */
  static highPassFilter(data, cutoffFreq = 0.5) {
    if (data.length < 3) return data;

    const samplingRate = EEG_CONFIG.SAMPLING_RATE;
    const rc = 1.0 / (cutoffFreq * 2 * Math.PI);
    const dt = 1.0 / samplingRate;
    const alpha = rc / (rc + dt);

    const filtered = [0];
    
    for (let i = 1; i < data.length; i++) {
      filtered[i] = alpha * (filtered[i - 1] + data[i] - data[i - 1]);
    }

    return filtered;
  }

  /**
   * Get power in a specific frequency band
   */
  static getBandPower(psd, band) {
    if (!Array.isArray(psd) || psd.length === 0) return 0;
    
    return psd
      .filter(bin => bin.frequency >= band.min && bin.frequency <= band.max)
      .reduce((sum, bin) => sum + bin.power, 0);
  }

  /**
   * Fallback basic band power calculation (original implementation)
   */
  static calculateBandPowersBasic(data, fs = EEG_CONFIG.SAMPLING_RATE) {
    // Apply simple filtering
    const filtered = this.lowPassFilter(this.highPassFilter(data));
    
    // Calculate PSD
    const psdResult = this.calculatePSD(filtered);
    
    // Convert to old format for compatibility
    const psd = psdResult.frequencies.map((freq, i) => ({
      frequency: freq,
      power: psdResult.powers[i] || 0
    }));
    
    // Calculate total power
    const totalPower = psd.reduce((sum, bin) => sum + bin.power, 0);
    
    if (totalPower === 0) {
      return {
        delta: 0,
        theta: 0,
        alpha: 0,
        beta: 0,
        gamma: 0,
        totalPower: 0,
        thetaContribution: 0,
        thetaSNR: 0,
        thetaPeakSNR: 0,
      };
    }

    // Calculate power in each frequency band
    const bands = {
      delta: this.getBandPower(psd, EEG_CONFIG.FREQUENCY_BANDS.DELTA),
      theta: this.getBandPower(psd, EEG_CONFIG.FREQUENCY_BANDS.THETA),
      alpha: this.getBandPower(psd, EEG_CONFIG.FREQUENCY_BANDS.ALPHA),
      beta: this.getBandPower(psd, EEG_CONFIG.FREQUENCY_BANDS.BETA),
      gamma: this.getBandPower(psd, EEG_CONFIG.FREQUENCY_BANDS.GAMMA),
    };

    // Normalize to relative power (0-1)
    return {
      delta: bands.delta / totalPower,
      theta: bands.theta / totalPower,
      alpha: bands.alpha / totalPower,
      beta: bands.beta / totalPower,
      gamma: bands.gamma / totalPower,
      totalPower: totalPower,
      thetaContribution: (bands.theta / totalPower) * 100,
      thetaSNR: 0,
      thetaPeakSNR: 0,
    };
  }

  /**
   * Remove eye blink artifacts (simplified moving window approach)
   */
  static removeEyeBlinkArtifacts(data, windowSize = 10) {
    if (data.length < windowSize) return data;

    const filtered = [...data];
    const threshold = 3; // Standard deviations

    for (let i = windowSize; i < data.length - windowSize; i++) {
      const window = data.slice(i - windowSize, i + windowSize);
      const mean = window.reduce((sum, val) => sum + val, 0) / window.length;
      const variance = window.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / window.length;
      const stdDev = Math.sqrt(variance);

      // Replace outliers with moving average
      if (Math.abs(data[i] - mean) > threshold * stdDev) {
        filtered[i] = mean;
      }
    }

    return filtered;
  }

  /**
   * Calculate signal variance (total power)
   */
  static calculateVariance(data) {
    const mean = data.reduce((sum, val) => sum + val, 0) / data.length;
    return data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / data.length;
  }

  /**
   * Integrate band power using Simpson's rule approximation
   */
  static integrateBandPower(powers, frequencies, lowFreq, highFreq) {
    const indices = [];
    for (let i = 0; i < frequencies.length; i++) {
      if (frequencies[i] >= lowFreq && frequencies[i] <= highFreq) {
        indices.push(i);
      }
    }

    if (indices.length === 0) return 0;

    let sum = 0;
    const dx = frequencies.length > 1 ? frequencies[1] - frequencies[0] : 1;

    for (const idx of indices) {
      sum += powers[idx] * dx;
    }

    return sum;
  }

  /**
   * Calculate Signal-to-Noise Ratio for a frequency band
   */
  static calculateBandSNR(powers, frequencies, lowFreq, highFreq) {
    const bandPower = this.integrateBandPower(powers, frequencies, lowFreq, highFreq);
    const totalPower = this.integrateBandPower(powers, frequencies, 0, frequencies[frequencies.length - 1]);
    const noisePower = totalPower - bandPower;
    
    return noisePower > 0 ? bandPower / noisePower : Number.POSITIVE_INFINITY;
  }

  /**
   * Calculate theta peak SNR (matches Python theta_peak_snr function)
   */
  static calculateThetaPeakSNR(powers, frequencies, signalBand = [3, 9], noiseBands = [[2, 3], [9, 10]]) {
    try {
      // Find signal indices
      const signalIndices = [];
      for (let i = 0; i < frequencies.length; i++) {
        if (frequencies[i] >= signalBand[0] && frequencies[i] <= signalBand[1]) {
          signalIndices.push(i);
        }
      }

      if (signalIndices.length === 0) return NaN;

      // Find peak signal in the theta band
      let maxSignal = 0;
      for (const idx of signalIndices) {
        if (powers[idx] > maxSignal) {
          maxSignal = powers[idx];
        }
      }

      // Calculate noise from flanking bands
      const noiseValues = [];
      for (const [low, high] of noiseBands) {
        for (let i = 0; i < frequencies.length; i++) {
          if (frequencies[i] >= low && frequencies[i] <= high) {
            noiseValues.push(powers[i]);
          }
        }
      }

      if (noiseValues.length === 0) return NaN;

      const meanNoise = noiseValues.reduce((sum, val) => sum + val, 0) / noiseValues.length;
      
      return meanNoise > 0 ? maxSignal / meanNoise : Number.POSITIVE_INFINITY;
    } catch (error) {
      console.error('Error calculating theta peak SNR:', error);
      return NaN;
    }
  }

  /**
   * Apply exponential smoothing to theta contribution with SNR adaptation
   */
  static applySmoothingToTheta(thetaContribution, thetaPeakSNR, alpha = 0.3) {
    // Store previous value for smoothing
    if (!this.previousThetaContribution) {
      this.previousThetaContribution = thetaContribution;
    }

    // Dynamically adapt theta contribution based on peak SNR
    let adaptedContribution = thetaContribution;
    if (isFinite(thetaPeakSNR) && thetaPeakSNR >= 0.2) {
      // Good signal quality, use as-is or slightly enhance
      adaptedContribution = thetaContribution * 1.1;
    } else {
      // Poor signal quality, reduce contribution
      adaptedContribution = thetaContribution * 0.8;
    }

    // Apply exponential smoothing
    const smoothed = alpha * adaptedContribution + (1 - alpha) * this.previousThetaContribution;
    this.previousThetaContribution = smoothed;

    return smoothed;
  }

  /**
   * Calculate attention and meditation indices (enhanced)
   */
  static calculateIndices(bandPowers) {
    // Enhanced attention index based on band powers
    const attention = bandPowers.beta / (bandPowers.alpha + bandPowers.theta + 0.001);
    
    // Enhanced meditation index
    const meditation = bandPowers.alpha / (bandPowers.beta + bandPowers.gamma + 0.001);
    
    // Include theta contribution in calculations
    const thetaFactor = Math.max(0, Math.min(1, bandPowers.thetaContribution / 100));
    
    // Normalize to 0-1 range with theta influence
    return {
      attention: Math.min(1, Math.max(0, (attention / 2) * (1 - thetaFactor * 0.3))),
      meditation: Math.min(1, Math.max(0, (meditation / 2) * (1 + thetaFactor * 0.2))),
      thetaContribution: bandPowers.thetaContribution,
      thetaSNR: bandPowers.thetaPeakSNR,
    };
  }

  /**
   * Detect artifacts in EEG data (enhanced)
   */
  static detectArtifacts(data, threshold = 3) {
    if (data.length < 10) return false;

    // Calculate standard deviation
    const mean = data.reduce((sum, val) => sum + val, 0) / data.length;
    const variance = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / data.length;
    const stdDev = Math.sqrt(variance);

    // Check for values beyond threshold * standard deviation
    const artifacts = data.filter(val => Math.abs(val - mean) > threshold * stdDev);
    
    // Also check for sudden spikes (eye blinks, muscle artifacts)
    let spikeCount = 0;
    for (let i = 1; i < data.length - 1; i++) {
      const diff1 = Math.abs(data[i] - data[i-1]);
      const diff2 = Math.abs(data[i+1] - data[i]);
      if (diff1 > 2 * stdDev && diff2 > 2 * stdDev) {
        spikeCount++;
      }
    }
    
    return artifacts.length > data.length * 0.1 || spikeCount > data.length * 0.05;
  }

  /**
   * Calculate signal quality metric (enhanced)
   */
  static calculateSignalQuality(data) {
    if (data.length < 10) return 0;

    // Check for artifacts
    const hasArtifacts = this.detectArtifacts(data);
    if (hasArtifacts) return 0.3;

    // Calculate signal-to-noise ratio approximation
    const mean = data.reduce((sum, val) => sum + val, 0) / data.length;
    const variance = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / data.length;
    
    // Check for reasonable EEG signal characteristics
    const signalRange = Math.max(...data) - Math.min(...data);
    const expectedRange = 500; // Typical EEG range in microvolts
    
    const rangeScore = Math.exp(-Math.abs(signalRange - expectedRange) / expectedRange);
    const varianceScore = Math.exp(-Math.abs(variance - 100) / 100); // Expected variance
    
    return Math.min(1, Math.max(0, (rangeScore + varianceScore) / 2));
  }

  /**
   * Create enhanced session summary from EEG data
   */
  static createSessionSummary(allData, duration) {
    if (!allData || allData.length === 0) {
      return {
        duration: 0,
        avgSignalQuality: 0,
        avgBandPowers: {
          delta: 0,
          theta: 0,
          alpha: 0,
          beta: 0,
          gamma: 0,
        },
        avgIndices: {
          attention: 0,
          meditation: 0,
          thetaContribution: 0,
          thetaSNR: 0,
        },
        totalSamples: 0,
        dataQuality: 'poor',
      };
    }

    // Calculate average band powers and advanced metrics
    const avgBandPowers = {
      delta: 0,
      theta: 0,
      alpha: 0,
      beta: 0,
      gamma: 0,
    };

    let signalQualitySum = 0;
    let attentionSum = 0;
    let meditationSum = 0;
    let thetaContributionSum = 0;
    let thetaSNRSum = 0;
    let validWindows = 0;

    // Process data in windows
    for (let i = 0; i < allData.length - EEG_CONFIG.WINDOW_SIZE; i += EEG_CONFIG.WINDOW_SIZE) {
      const window = allData.slice(i, i + EEG_CONFIG.WINDOW_SIZE);
      
      const bandPowers = this.calculateBandPowers(window);
      const indices = this.calculateIndices(bandPowers);
      const quality = this.calculateSignalQuality(window);

      avgBandPowers.delta += bandPowers.delta;
      avgBandPowers.theta += bandPowers.theta;
      avgBandPowers.alpha += bandPowers.alpha;
      avgBandPowers.beta += bandPowers.beta;
      avgBandPowers.gamma += bandPowers.gamma;

      signalQualitySum += quality;
      attentionSum += indices.attention;
      meditationSum += indices.meditation;
      thetaContributionSum += indices.thetaContribution;
      thetaSNRSum += indices.thetaSNR;
      validWindows++;
    }

    if (validWindows > 0) {
      avgBandPowers.delta /= validWindows;
      avgBandPowers.theta /= validWindows;
      avgBandPowers.alpha /= validWindows;
      avgBandPowers.beta /= validWindows;
      avgBandPowers.gamma /= validWindows;
    }

    const avgQuality = validWindows > 0 ? signalQualitySum / validWindows : 0;
    const avgThetaContribution = validWindows > 0 ? thetaContributionSum / validWindows : 0;

    // Determine data quality rating
    let dataQuality = 'poor';
    if (avgQuality > 0.8) dataQuality = 'excellent';
    else if (avgQuality > 0.6) dataQuality = 'good';
    else if (avgQuality > 0.4) dataQuality = 'fair';

    return {
      duration: duration,
      avgSignalQuality: avgQuality,
      avgBandPowers,
      avgIndices: {
        attention: validWindows > 0 ? attentionSum / validWindows : 0,
        meditation: validWindows > 0 ? meditationSum / validWindows : 0,
        thetaContribution: avgThetaContribution,
        thetaSNR: validWindows > 0 ? thetaSNRSum / validWindows : 0,
      },
      totalSamples: allData.length,
      dataQuality: dataQuality,
    };
  }

  /**
   * Process real-time data with advanced metrics (main processing function)
   */
  static processRealtimeData(dataBuffer) {
    if (dataBuffer.length < EEG_CONFIG.WINDOW_SIZE) {
      return null;
    }

    try {
      const latestWindow = dataBuffer.slice(-EEG_CONFIG.WINDOW_SIZE);
      
      // Use the advanced processor directly for better performance and accuracy
      const result = advancedProcessor.process(latestWindow);
      
      // Log detailed metrics like Python implementation
      const peakSNRDisplay = isFinite(result.thetaMetrics.thetaSNRPeak) ? 
        result.thetaMetrics.thetaSNRPeak.toFixed(2) : "‚àû";
      
      console.log(`üß† Theta contribution: ${result.thetaMetrics.thetaContribution.toFixed(1)}% | ` +
                  `Peak Œ∏-SNR: ${peakSNRDisplay} | ` +
                  `Smoothed: ${result.thetaMetrics.smoothedTheta.toFixed(1)}%`);
      console.log(`üß† Band Powers - Œ¥:${result.bandPowers.delta.toFixed(1)} ` +
                  `Œ∏:${result.bandPowers.theta.toFixed(1)} ` +
                  `Œ±:${result.bandPowers.alpha.toFixed(1)} ` +
                  `Œ≤:${result.bandPowers.beta.toFixed(1)} ` +
                  `Œ≥:${result.bandPowers.gamma.toFixed(1)}`);

      // Calculate band powers for UI display (using the advanced result)
      const bandPowers = this.calculateBandPowers(latestWindow);
      const indices = this.calculateIndices(bandPowers);
      const quality = this.calculateSignalQuality(latestWindow);

      return {
        timestamp: Date.now(),
        bandPowers: bandPowers,
        indices: indices,
        signalQuality: quality,
        // Advanced result data for detailed analysis
        advancedResult: result,
        // Payload format matching Python for API (use the exact payload from advanced processor)
        payload: result.payload
      };
    } catch (error) {
      console.error('‚ùå Advanced realtime processing failed:', error);
      // Fallback to basic processing
      const latestWindow = dataBuffer.slice(-EEG_CONFIG.WINDOW_SIZE);
      const bandPowers = this.calculateBandPowersBasic(latestWindow);
      const indices = this.calculateIndices(bandPowers);
      const quality = this.calculateSignalQuality(latestWindow);

      return {
        timestamp: Date.now(),
        bandPowers: bandPowers,
        indices: indices,
        signalQuality: quality,
        payload: {
          'Total variance (power)': bandPowers.totalPower,
          'Delta power': bandPowers.delta,
          'Theta power': bandPowers.theta,
          'Theta contribution': bandPowers.thetaContribution,
          'Theta relative': bandPowers.theta,
          'Theta SNR broad': bandPowers.thetaSNR,
          'Theta SNR peak': bandPowers.thetaPeakSNR,
          'Alpha power': bandPowers.alpha,
          'Beta power': bandPowers.beta,
          'Gamma power': bandPowers.gamma,
        }
      };
    }
  }
}

export default EEGProcessor;
